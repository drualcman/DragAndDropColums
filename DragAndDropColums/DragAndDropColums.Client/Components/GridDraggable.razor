@* GridDraggable.razor - Sin JavaScript *@
<div class="drag-container"
     @ref="containerRef"
     @onmousemove="OnMouseMove"
     @onmouseup="OnMouseUp">

    @foreach (var item in Layout.Items.OrderBy(i => i.Order))
    {
        var isDragging = draggingItem?.Id == item.Id;

        <div class="grid-item @(isDragging ? "dragging" : "") @(IsDropTarget(item) ? "drop-target" : "")"
             style="@GetItemStyle(item, isDragging)"
             @onmousedown="@(e => StartDrag(item, e))"
             @onmouseenter="@(() => HandleMouseEnter(item))">

            <div class="content">
                @item.Title
                <small>
                    @(item.IsFullWidth ? "Full width" : "Half")
                    (Fila @item.Row)
                </small>
            </div>
        </div>
    }

    <!-- Indicador visual de drop position -->
    @if (showDropIndicator && dropRow >= 0)
    {
        <div class="drop-indicator"
             style="@GetDropIndicatorStyle()">
            <span>⬇ Soltar aquí (Fila @dropRow)</span>
        </div>
    }
</div>

@code {
    [Parameter] public GridLayout Layout { get; set; } = new();
    [Parameter] public int ContainerPadding { get; set; } = 20;

    private GridItem? draggingItem;
    private GridItem? dropTargetItem;
    private bool isDragging = false;
    private double startX, startY;
    private double currentX, currentY;
    private int dropRow = -1;
    private int dropColumn = 1;
    private bool showDropIndicator = false;
    private ElementReference containerRef;
    private double? containerScreenX = null;
    private double? containerScreenY = null;

    // Constantes de diseño
    private const int RowHeight = 140;
    private const int Gap = 12;
    private const int ColumnWidthPercent = 48;

    // Estilo para los elementos
    private string GetItemStyle(GridItem item, bool isDragging)
    {
        if (isDragging)
        {
            // Durante el drag: posición absoluta relativa al documento
            // Usamos transform para mejor performance
            return $"position: absolute; " +
                   $"transform: translate({currentX}px, {currentY}px) rotate(2deg); " +
                   $"width: {(item.IsFullWidth ? "100%" : "calc(50% - 14px)")}; " +
                   $"height: {RowHeight}px; " +
                   $"z-index: 1000; " +
                   $"pointer-events: none; " +
                   $"opacity: 0.9; " +
                   $"margin: 0 8px;";
        }
        else
        {
            // Posición normal en grid
            var leftPercent = item.IsFullWidth ? 0 : (item.Column == 1 ? 0 : 52);
            var widthPercent = item.IsFullWidth ? 100 : ColumnWidthPercent;

            return $"position: absolute; " +
                   $"left: {leftPercent}%; " +
                   $"top: {item.Row * (RowHeight + Gap)}px; " +
                   $"width: {widthPercent}%; " +
                   $"height: {RowHeight}px; " +
                   $"z-index: {(IsDropTarget(item) ? 2 : 1)}; " +
                   $"transition: {(isDragging ? "none" : "all 0.3s ease")};";
        }
    }

    private string GetDropIndicatorStyle()
    {
        var left = dropColumn == 1 ? "0%" : "52%";
        var width = draggingItem?.IsFullWidth == true ? "100%" : "48%";

        return $"position: absolute; " +
               $"left: {left}; " +
               $"top: {dropRow * (RowHeight + Gap)}px; " +
               $"width: {width}; " +
               $"height: {RowHeight}px; " +
               $"border: 2px dashed #28a745; " +
               $"background: rgba(40, 167, 69, 0.1); " +
               $"border-radius: 8px; " +
               $"z-index: 5; " +
               $"display: flex; " +
               $"align-items: center; " +
               $"justify-content: center; " +
               $"color: #28a745; " +
               $"font-weight: bold;";
    }

    private void SetContainerRef(ElementReference element)
    {
        containerRef = element;
        // No usamos JS para obtener posición, usamos un enfoque diferente
    }

    private void StartDrag(GridItem item, MouseEventArgs e)
    {
        draggingItem = item;
        isDragging = true;
        showDropIndicator = false;

        // Capturar la posición inicial del ratón
        startX = e.ClientX;
        startY = e.ClientY;

        // Calcular la posición actual del elemento en pantalla
        // Estimamos basado en su posición en el grid
        var itemTop = item.Row * (RowHeight + Gap);
        var itemLeftPercent = item.IsFullWidth ? 0 : (item.Column == 1 ? 0 : 52);

        // Estimación: asumimos que el contenedor empieza en (0,0) relativo al viewport
        // Esto funciona si el contenedor no tiene desplazamiento complejo
        currentX = (itemLeftPercent / 100.0) * 800; // 800px es estimación de ancho
        currentY = itemTop;

        // Offset del ratón dentro del elemento
        var offsetX = e.ClientX - currentX;
        var offsetY = e.ClientY - currentY;

        // Guardar el offset para cálculos posteriores
        this.startX = offsetX;
        this.startY = offsetY;

        // Inicializar posición actual
        currentX = e.ClientX - offsetX;
        currentY = e.ClientY - offsetY;

        StateHasChanged();
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (!isDragging || draggingItem == null)
            return;

        // Actualizar posición del elemento arrastrado
        currentX = e.ClientX - startX;
        currentY = e.ClientY - startY;

        // Calcular la fila objetivo basada en la posición Y
        // Asumimos que el contenedor empieza en Y=0 (scroll manejado por contenedor padre)
        dropRow = (int)Math.Floor(currentY / (RowHeight + Gap));
        if (dropRow < 0)
            dropRow = 0;

        // Calcular columna basada en posición X
        // Estimamos ancho del contenedor como 800px
        var containerWidth = 800;
        dropColumn = currentX > containerWidth * 0.5 ? 2 : 1;

        // Si es full width, siempre columna 1
        if (draggingItem.IsFullWidth)
        {
            dropColumn = 1;
        }

        showDropIndicator = true;
        StateHasChanged();
    }

    private void HandleMouseEnter(GridItem item)
    {
        if (!isDragging || draggingItem == null || draggingItem.Id == item.Id)
            return;

        dropTargetItem = item;
        StateHasChanged();
    }

    private bool IsDropTarget(GridItem item)
    {
        return dropTargetItem?.Id == item.Id && isDragging;
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        if (!isDragging || draggingItem == null)
            return;

        try
        {
            // Usar la posición calculada durante el drag
            if (dropRow >= 0)
            {
                // Crear posición candidata
                var candidate = new GridItem
                {
                    Row = dropRow,
                    Column = draggingItem.IsFullWidth ? 1 : dropColumn,
                    IsFullWidth = draggingItem.IsFullWidth
                };

                // Quitar temporalmente el item actual
                Layout.RemoveFromOccupied(draggingItem);

                // Intentar colocar en la posición deseada
                if (Layout.CanPlace(candidate))
                {
                    draggingItem.Row = candidate.Row;
                    draggingItem.Column = candidate.Column;
                }
                else
                {
                    // Buscar posición más cercana disponible
                    FindAndSetClosestPosition(draggingItem, candidate);
                }

                // Reordenar todo
                Layout.RecalculateOccupied();
                Layout.ReorderAll();
            }
        }
        finally
        {
            // Limpiar estado
            isDragging = false;
            draggingItem = null;
            dropTargetItem = null;
            showDropIndicator = false;
            dropRow = -1;
            StateHasChanged();
        }
    }

    private void FindAndSetClosestPosition(GridItem item, GridItem desiredPos)
    {
        // Buscar hacia abajo
        for (int offset = 0; offset < 10; offset++)
        {
            var testPos = new GridItem
            {
                Row = desiredPos.Row + offset,
                Column = desiredPos.Column,
                IsFullWidth = desiredPos.IsFullWidth
            };

            if (Layout.CanPlace(testPos))
            {
                item.Row = testPos.Row;
                item.Column = testPos.Column;
                return;
            }
        }

        // Si no encuentra hacia abajo, buscar hacia arriba
        for (int offset = 1; offset < 10; offset++)
        {
            var testPos = new GridItem
            {
                Row = Math.Max(0, desiredPos.Row - offset),
                Column = desiredPos.Column,
                IsFullWidth = desiredPos.IsFullWidth
            };

            if (Layout.CanPlace(testPos))
            {
                item.Row = testPos.Row;
                item.Column = testPos.Column;
                return;
            }
        }

        // Último recurso: poner al final
        item.Row = Layout.Items.Max(i => i.Row) + 1;
        item.Column = desiredPos.Column;
    }

    // Método para manejar scroll si es necesario
    private void OnScroll(EventArgs e)
    {
        // Si el contenedor está dentro de un scrollable container,
        // necesitaríamos trackear el scroll offset
        // Esto se puede hacer con un componente padre que pase el offset como parámetro
    }
}